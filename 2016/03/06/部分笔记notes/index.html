<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java,线程,数据结构,加密算法,Stream,lambda," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="简介：Java 日常比较零碎的知识点记录：Java 线程，与线程池，线程通信，Java 泛型，Stream，Lambda表达式，Java 加密算法，Java mail">
<meta name="keywords" content="Java,线程,数据结构,加密算法,Stream,lambda">
<meta property="og:type" content="article">
<meta property="og:title" content="部分笔记">
<meta property="og:url" content="http://rtry.xyz/2016/03/06/部分笔记notes/index.html">
<meta property="og:site_name" content="Rtry&#39;s blog">
<meta property="og:description" content="简介：Java 日常比较零碎的知识点记录：Java 线程，与线程池，线程通信，Java 泛型，Stream，Lambda表达式，Java 加密算法，Java mail">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://rtry.xyz/uploads/notes/11182147-200b853b8a954defab784cc653e964021.jpg">
<meta property="og:image" content="http://rtry.xyz/uploads/notes/11182519-1c215a72b08142ae90b4f7143d83e84c1.jpg">
<meta property="og:updated_time" content="2019-05-16T10:09:49.541Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="部分笔记">
<meta name="twitter:description" content="简介：Java 日常比较零碎的知识点记录：Java 线程，与线程池，线程通信，Java 泛型，Stream，Lambda表达式，Java 加密算法，Java mail">
<meta name="twitter:image" content="http://rtry.xyz/uploads/notes/11182147-200b853b8a954defab784cc653e964021.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rtry.xyz/2016/03/06/部分笔记notes/"/>





  <title>部分笔记 | Rtry's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rtry's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">活在当下 积极向上</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rtry.xyz/2016/03/06/部分笔记notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Felicity.R.try">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rtry's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">部分笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-06T00:00:00+08:00">
                2016-03-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-05-16T18:09:49+08:00">
                2019-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工作与学习/" itemprop="url" rel="index">
                    <span itemprop="name">工作与学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>简介：Java 日常比较零碎的知识点记录：Java 线程，与线程池，线程通信，Java 泛型，Stream，Lambda表达式，Java 加密算法，Java mail<br><a id="more"></a></p>
<h2 id="StringBuffer-and-StringBuilder"><a href="#StringBuffer-and-StringBuilder" class="headerlink" title="StringBuffer and StringBuilder"></a>StringBuffer and StringBuilder</h2><ol>
<li>两者兼容API</li>
<li>StringBuffer 线程安全</li>
<li>StringBuilder 多线程不安全，但是更快</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="两个特性"><a href="#两个特性" class="headerlink" title="两个特性"></a>两个特性</h3><p>在多个线程共享某个对象X时，X首先存在于主线程的堆内存中，不同的线程对X的操作实际上是，分3步完成，首先拷贝副本到线程栈中，然后执行某些操作，最后将X回刷回主线程的堆内存。</p>
<ol>
<li><p>可见性 ：<br>多线程中，某些线程对X进行修改，其他线程也能看到被修改的X 此为可见性</p>
</li>
<li><p>有序性 ：<br>对X的操作，如果要求必须等到前一个线程完整之后，后一次线程才操作 此为有序性</p>
</li>
</ol>
<blockquote>
<p>Main 方法执行中，如果另起线程中，线程挂起，主线程是不会关闭的</p>
<p>JUnit 执行测试时，如果另起线程中，线程挂起，主线程任然会关闭</p>
</blockquote>
<h2 id="Java-1-5之前对线程同步的方式"><a href="#Java-1-5之前对线程同步的方式" class="headerlink" title="Java 1.5之前对线程同步的方式"></a>Java 1.5之前对线程同步的方式</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li>修饰一个代码块，其同步的作用域是{}之间的代码，锁是（）里面的东西，作用的对象是调用该代码块的类（及一个时间只有一个对象可以调用这个代码块）</li>
<li>修饰一个方法，其同步的是作用域是整个方法里面的代码，锁 是当前方法所属的对象，作用的对象是调用当前方法的对象（及一个时间只有一个对象可以调用该方法）</li>
<li>修饰一个静态方法，其同步的作用域是整个方法里面的代码，锁是当前方法所属类A，而类所有的实例都是共用一个类的，故对所有实例都有效（及一个时间只有一个对象可以调用该方法，更加严格的，两个类A的实例给其他对象加锁用，但这两个类A都是用的同一把锁）</li>
<li>修改一个类，其所有方法同步，锁是当前类A，同第3点</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 具有synchronized的可见性，不具有synchronized的有序性(原子性)，</p>
<ul>
<li>其性能优于synchronized</li>
<li>严格遵循 volatile 的使用条件 —— <strong>即变量真正独立于其他变量和自己以前的值</strong> </li>
<li>volatile只能保证对单次读/写的原子性</li>
</ul>
<p>对volatile 修饰的变量的与普通的变量修改的区别有两点</p>
<ul>
<li>修改volatile变量的会强制将修改后的值刷新到主内存中</li>
<li>修改volatile变量的会造成其他线程对该变量应用的失效</li>
</ul>
<p>volatile关键字只能保证get操作是读取的是最新的值，而set操作会写到内存中，会强制重新从系统内存里把数据读到处理器缓存里，并不具有原子性</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>一个地方写，很多地方读取，这个时候使用volatile会让每个地方获取的值都是最新的</li>
<li><p>volatile 和 synchronized 实现 “开销较低的读－写锁”</p>
<pre><code>public class CheesyCounter {

    private volatile int value;

    public int getValue() { 
        return value;
     }
    public synchronized int increment() {
        return value++;
    }
}
</code></pre></li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>从逻辑上说：集合，线形，树形，图形</li>
<li>从物理上说：顺序，链式，索引，散列</li>
</ul>
<h3 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h3><ul>
<li>线性表（链表）</li>
<li>队列 （先进先出）</li>
<li>栈（后进先出）</li>
<li>树 </li>
<li>图 </li>
</ul>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul>
<li>二叉搜索树的特点是，小的值在左边，大的值在右边，即</li>
</ul>
<p><img src="/uploads/notes/11182147-200b853b8a954defab784cc653e964021.jpg" alt="2"></p>
<ul>
<li>如实例：</li>
</ul>
<p><img src="/uploads/notes/11182519-1c215a72b08142ae90b4f7143d83e84c1.jpg" alt="2"></p>
<p>可以非常方便的获取最大值，最小值，某元素的前驱，某元素的后驱</p>
<ul>
<li><p>最大值：树的最右节点。</p>
</li>
<li><p>最小值：树的最左节点。</p>
</li>
<li><p>某元素前驱：左子树的最右。</p>
</li>
<li><p>某元素的后继：右子树的最左。</p>
</li>
</ul>
<p>由上可知，二叉搜索树的dictionary operation（包括search、insertion、deletion）的时间复杂度均与O(h)相关，h为树的高度（log n），如果按照上述的insertion方法构建树，那么构建出来的树的形状各异，特别是当输入序列有序时，更会退化到链表的程度。所以，如果能用某种方法，将树的高度降低到最小，那么其dictionary operation的时间开销均可以降低，不过相对而言构建树的开销将增大。为了降低二叉搜索树的高度而提出了平衡二叉树（Balanced Binary Tree）的概念。它要求左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这样就可以将搜索树的高度尽量减小。常用算法有红黑树、AVL、Treap、伸展树等。</p>
<h3 id="扩展（对数-）"><a href="#扩展（对数-）" class="headerlink" title="扩展（对数 ）"></a>扩展（对数 ）</h3><ul>
<li>log表示对数。</li>
<li>如果a^n = b（a&gt;0，且a≠1），那么数n叫做以a为底b的对数，记做n=log(a)b，【a是下标】</li>
<li>其中，a叫做“底数”，b叫做“真数”。　　</li>
<li>相应地，函数y=logaX叫做对数函数。对数函数的定义域是（0，+∞）。零和负数没有对数。</li>
<li>底数a为常数，其取值范围是（0，1）∪（1，+∞）。</li>
<li>当a=10时，写作：y=lgx【常用对数】。</li>
<li>当a=e【自然对数的底数】时，写作y=lnx</li>
<li>例：2^3 =8</li>
<li>那么 log(2) 8 = 3</li>
</ul>
<h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><p>待补充</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="解决目的"><a href="#解决目的" class="headerlink" title="解决目的"></a>解决目的</h3><blockquote>
<p>线程池 （从1.5版本开始）</p>
<p>线程的创建，消费，对内存的开销很大，创建线程也会带来额外的性能支出（如创建时间）</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote>
<p>有4个，但都是由下面这个变种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// corePoolSize :核心池大小数，在创建线程池对象的时候，核心池的大小其实是0的，然后在往线程池里面添加任务的时候，初始化一个线程</span><br><span class="line">// maximumPoolSize:池最大数，表示当前当前线程池允许的最大线程数</span><br><span class="line">// keepAliveTime：空闲线程允许存活时间，当线程空闲时，这个线程等待多长时间进行释放回收，</span><br><span class="line">// TimeUnit: 时间类型，keepAliveTime的时间类型参数（7种）</span><br><span class="line">// workQueue：阻塞队列，用来存储等待执行的任务，有多种如 `ArrayBlockingQueue` `LinkedBlockingQueue`  `SynchronousQueue`</span><br><span class="line">ArrayBlockingQueue：基于数组实现，初始时，需要指定大小，先进先出</span><br><span class="line">LinkedBlockingQueue：基于链表的实现，初始时，可不指定大小，默认为Int的max，先进先出</span><br><span class="line">SynchronousQueue：该队列不会保存任务，直接提交执行</span><br><span class="line">// threadFactory ：线程工厂</span><br><span class="line">// handler：表示拒绝服务的策略(有4种)</span><br><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Executors-工具类"><a href="#Executors-工具类" class="headerlink" title="Executors 工具类"></a>Executors 工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(4);</span><br><span class="line">// 创建一个固定大小的线程池，加入一个任务，就创建一个线程池，直到满了线程池的核心池大小，然后再加入的时候，会等空闲的线程池</span><br><span class="line"></span><br><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">// 创建一个可变的线程池，加入一个任务，先看有没有空闲线程，有的话直接取来，没有的话，创建一个新的</span><br><span class="line"></span><br><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(3);</span><br><span class="line">// 创建一个固定大小的线程池，用于处理定时及周期性任务注意其返回ScheduledExecutorService  </span><br><span class="line"></span><br><span class="line">ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">// 创建一个独立的线程池，只有一个线程来执行，保证队列里面的**时序**</span><br></pre></td></tr></table></figure>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Eclipse-Scala-插件"><a href="#Eclipse-Scala-插件" class="headerlink" title="Eclipse  Scala 插件"></a>Eclipse  Scala 插件</h3><p>安装文档及说明地址： <a href="http://scala-ide.org/download/current.html" target="_blank" rel="noopener">http://scala-ide.org/download/current.html</a></p>
<h3 id="Maven-maven-assembly-plugin-插件"><a href="#Maven-maven-assembly-plugin-插件" class="headerlink" title="Maven maven-assembly-plugin 插件"></a>Maven maven-assembly-plugin 插件</h3><blockquote>
<p>在 pom.xml &lt; build&gt; 里面 添加插件</p>
<p>打单独包的插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">		&lt;!-- url --&gt;</span><br><span class="line">		&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 配置--&gt; </span><br><span class="line">		&lt;configuration&gt;</span><br><span class="line">			&lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;</span><br><span class="line">			&lt;!-- 依赖配置文件 --&gt;</span><br><span class="line">			&lt;descriptors&gt;</span><br><span class="line">				&lt;descriptor&gt;src/main/resources/assembly.xml&lt;/descriptor&gt;</span><br><span class="line">			&lt;/descriptors&gt;</span><br><span class="line">			&lt;!-- 主函数入口 --&gt;</span><br><span class="line">			&lt;archive&gt;</span><br><span class="line">				&lt;manifest&gt;</span><br><span class="line">					&lt;mainClass&gt;pt.sicau.edu.cn.spark.test.StreamPublicSecond&lt;/mainClass&gt;</span><br><span class="line">				&lt;/manifest&gt;</span><br><span class="line">			&lt;/archive&gt;</span><br><span class="line">		&lt;/configuration&gt;</span><br><span class="line">		&lt;!-- 执行 --&gt;</span><br><span class="line">		&lt;executions&gt;</span><br><span class="line">			&lt;execution&gt;</span><br><span class="line">				&lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">				&lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">				&lt;!-- 单例 --&gt;</span><br><span class="line">				&lt;goals&gt;</span><br><span class="line">					&lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">				&lt;/goals&gt;</span><br><span class="line">			&lt;/execution&gt;</span><br><span class="line">		&lt;/executions&gt;</span><br><span class="line">	&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>assembly.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;assembly xmlns=&quot;http://maven.apache.org/ASSEMBLY/2.0.0&quot;</span><br><span class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;id&gt;test&lt;/id&gt;</span><br><span class="line">	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;</span><br><span class="line">	&lt;formats&gt;</span><br><span class="line">		&lt;format&gt;jar&lt;/format&gt;</span><br><span class="line">	&lt;/formats&gt;</span><br><span class="line"></span><br><span class="line">	&lt;fileSets&gt;</span><br><span class="line">		&lt;!-- resources --&gt;</span><br><span class="line">		&lt;fileSet&gt;</span><br><span class="line">			&lt;directory&gt;$&#123;project.basedir&#125;\src\main\resources&lt;/directory&gt;</span><br><span class="line">			&lt;outputDirectory&gt;\&lt;/outputDirectory&gt;</span><br><span class="line">		&lt;/fileSet&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- my app class --&gt;</span><br><span class="line">		&lt;fileSet&gt;</span><br><span class="line">			&lt;directory&gt;$&#123;project.basedir&#125;\target\classes&lt;/directory&gt;</span><br><span class="line">			&lt;outputDirectory&gt;\&lt;/outputDirectory&gt;</span><br><span class="line">		&lt;/fileSet&gt;</span><br><span class="line">	&lt;/fileSets&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencySets&gt;</span><br><span class="line">		&lt;!-- denpendency jars --&gt;</span><br><span class="line">		&lt;dependencySet&gt;</span><br><span class="line">			&lt;!--将依赖解压--&gt;</span><br><span class="line">			&lt;unpack&gt;true&lt;/unpack&gt;</span><br><span class="line">			&lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt;</span><br><span class="line">			&lt;outputDirectory&gt;\&lt;/outputDirectory&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">		&lt;/dependencySet&gt;</span><br><span class="line">	&lt;/dependencySets&gt;</span><br><span class="line"></span><br><span class="line">&lt;/assembly&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Java-Puzzlers"><a href="#Java-Puzzlers" class="headerlink" title="Java Puzzlers"></a>Java Puzzlers</h2><ul>
<li>URL的equals比对方式,在有网时，会根据解析地址来判断，地址相同则相同，在没网时，会根据字符串来判断，但是域名不区分大小写</li>
<li>j++ 与 ++j 这种运算存在一个临时中间变量</li>
<li>static 方法是类的，不会被继承</li>
<li>for 循环只有一行时，可以省下{} ，但是不能是赋值语句</li>
<li>Integer 与int相比，值等就等，Integer对象之间比较，在byte范围内，必然相等</li>
<li>BigInteger.add()方法，返回的是加的结果，原值是不会改变的</li>
<li>Integer 静态方法，可以方便的转换2/8/16进制</li>
<li>基本上所有容器类的构造方法都有参数为容器的</li>
<li>&lt;&lt; 与 &gt;&gt; 为位运算，表示将二进制左右移动，很方便的实现开方</li>
<li>String.format() 工具类，可快速格式化</li>
<li>Char 在英文编码范围是有缓存的，故包装类之间比较这个范围，是相等的</li>
<li>Math.abs() Integer.min() 的时候，自身相等</li>
<li>java的重载方法，在调用的时候，会选取最适中的</li>
<li>Number是所有数字类的父类 </li>
<li>Class.forName() 将类加入编译环境 ，c.newInstance() 会调用无参构造方法</li>
<li>Timer 与TimerTask 两个是java处理定时器相关的两个类</li>
</ul>
<h2 id="Java-Generics-泛型"><a href="#Java-Generics-泛型" class="headerlink" title="Java Generics 泛型"></a>Java Generics 泛型</h2><ul>
<li>必须先声明 <t>  可在类上 或者方法上声明 </t></li>
<li>是否拥有泛型方法 跟是否是泛型类 无关</li>
<li>泛型在编译阶段中，会将泛型进行擦除，也就是说成功编译后的泛型，是不包含任何泛型信息的</li>
<li>多重泛型 类放第一位，接口从第二位开始，用&amp; 连接</li>
</ul>
<h2 id="Java-Lambda-表达式"><a href="#Java-Lambda-表达式" class="headerlink" title="Java Lambda 表达式"></a>Java Lambda 表达式</h2><blockquote>
<p>自1.8之后引入，java的一个重要变更，是Stream的使用基础</p>
<p>替代只有一个抽象方法的接口在代码内中匿名直接使用</p>
</blockquote>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><blockquote>
<p><strong>参数列表 -&gt; 函数体</strong></p>
<ul>
<li>参数列表有() 括起来，如果只有一个，可省略括号</li>
<li>函数体 可以是一个表达式，也可以是一个语句块</li>
</ul>
</blockquote>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>如果函数体，是一个表达式，会将执行结果返回给匿名调用者<br>如果是语句块，会将return 返回给调用者</p>
<h3 id="内部接口单一方法替代"><a href="#内部接口单一方法替代" class="headerlink" title="内部接口单一方法替代"></a>内部接口单一方法替代</h3><blockquote>
<p>需要接口中只有单一抽象方法</p>
<p>() -&gt; 代替内部匿名接口</p>
</blockquote>
<h3 id="函数体引用值"><a href="#函数体引用值" class="headerlink" title="函数体引用值"></a>函数体引用值</h3><blockquote>
<p>在lambda中，引入外部变量，可不定义成final,但是其本质还是final的</p>
<p>闭包，运行我们创建函数指针，并把他们作为参数传递</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface Geek &#123;</span><br><span class="line">	void geet();</span><br><span class="line">	// 这里不能有两个方法，不然lambda表达式不能代替</span><br><span class="line">	// void geet2();</span><br><span class="line">&#125;</span><br><span class="line">public class Teek &#123;</span><br><span class="line">	public void hello(Geek g) &#123;</span><br><span class="line">		g.geet();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Teek t = new Teek();</span><br><span class="line">	t.hello(() -&gt; System.out.println(&quot;xxxxx&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果接口的方法 是有参数的情况</span><br><span class="line">public static String[] players = &#123; &quot;Rafael Nadal hello word &quot;, &quot;Novak Djokovic&quot; &#125;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	Arrays.sort(players, (String s1, String s2) -&gt; s1.length() - s2.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合迭代"><a href="#集合迭代" class="headerlink" title="集合迭代"></a>集合迭代</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	List&lt;String&gt; lists = Arrays.asList(&quot;java&quot;, &quot;scala&quot;, &quot;python&quot;);</span><br><span class="line"></span><br><span class="line">	// old</span><br><span class="line">	for (String str : lists)</span><br><span class="line">		System.out.println(str);</span><br><span class="line"></span><br><span class="line">	// new</span><br><span class="line">	lists.forEach((String s) -&gt; System.out.println(s));</span><br><span class="line">	// 等同于</span><br><span class="line">	lists.forEach(s -&gt; System.out.println(s));</span><br><span class="line">	// 再等同于</span><br><span class="line">	lists.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><blockquote>
<p>是Java 8 对一类特殊类型的接口的称呼，这类接口只定义一个唯一抽象方法，用作lambda表达式    </p>
</blockquote>
<blockquote>
<p>具体的类的方法，必须跟函数接口声明一致，方法必须为static</p>
</blockquote>
<blockquote>
<p>@FunctionalInterface 可以在函数接口上声明，便于编译器优化，如果不是函数接口，那么添加注解会报错</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Magic5 m6 = MyMagic::show;</span><br><span class="line">m6.show(1, &quot;xxx&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="Java-Stream-语法"><a href="#Java-Stream-语法" class="headerlink" title="Java Stream 语法"></a>Java Stream 语法</h2><blockquote>
<p>Stream 是Java 8 推出</p>
<p>Stream 是用函数式编程的方式来处理集合类上的负责操作（循环，查找，过滤等）</p>
<p>其一系列的操作都是在操作Stream,直到feach时才会操作结果，这种迭代方式称为内部迭代。</p>
</blockquote>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ul>
<li>创建Stream:通过stream()方法等，取得集合对象的数据集。</li>
<li>Intermediate:通过一系列中间（Intermediate）方法，对数据集进行过滤、检索等数据集的再次处理。如上例中，使用filter()方法来对数据集进行过滤。</li>
<li>Terminal通过最终（terminal）方法完成对数据集中元素的处理。如上例中，使用forEach()完成对过滤后元素的打印。<blockquote>
<p>在一次聚合操作中，可以有多个Intermediate，但是有且只有一个Terminal</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>Stream的操作分类</p>
<ul>
<li>Intermediate：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 skip、 parallel、 sequential、 unordered</li>
</ul>
</blockquote>
<ul>
<li><p>Terminal：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、iterator</p>
</li>
<li><p>Short-circuiting： anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long count = allArtists.stream()</span><br><span class="line">    .filter(artist -&gt; &#123;</span><br><span class="line">        System.out.println(artist.getName());</span><br><span class="line">            return artist.isFrom(&quot;London&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">    .count();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>惰性求值和及早求值方法</p>
<ul>
<li>如何判断一个操作是惰性求值还是及早求值，其实很简单，只需要看其返回值即可：如果返回值是Stream，那么就是惰性求值；如果返回值不是Stream或者是void，那么就是及早求值。上面的示例中，只是包含两步：一个惰性求值-filter和一个及早求值-count。</li>
</ul>
</blockquote>
<ul>
<li>前面，已经说过，在一个Stream操作中，可以有多次惰性求值，但有且仅有一次及早求值。</li>
</ul>
<h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><ul>
<li>Stream接口提供的静态方法，of,generate,iterate</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建长度为3的Stream</span><br><span class="line">br();</span><br><span class="line">Stream&lt;Integer&gt; is = Stream.of(1, 3, 4);</span><br><span class="line">System.out.println(is.findAny().get());</span><br><span class="line"></span><br><span class="line">// 返回无效长度的Stream</span><br><span class="line">br();</span><br><span class="line">Stream&lt;Double&gt; d = Stream.generate(() -&gt; Math.random());</span><br><span class="line">d.limit(3L).forEach(x -&gt; System.out.println(x));</span><br><span class="line">br();</span><br><span class="line">Stream&lt;Integer&gt; ii = Stream.iterate(1, i -&gt; i + 1);</span><br><span class="line">ii.limit(3L).forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Collection接口和数组的默认方法</p>
<blockquote>
<p>Collection集合类，在接口上已经实现抽象，</p>
<p>数组是使用静态的方法进行实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(ga).forEach(i -&gt; System.out.println(i.getName()));</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>其他创建Stream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random.ints()</span><br><span class="line">BitSet.stream()</span><br><span class="line">Pattern.splitAsStream(java.lang.CharSequence)</span><br><span class="line">JarFile.stream()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h3><blockquote>
<p>Intermediate主要是用来对Stream做出相应转换及限制流，实际上是将源Stream转换为一个新的Stream，以达到需求效果。</p>
<ul>
<li>concat方法将两个Stream连接在一起，合成一个Stream</li>
<li>distinct方法以达到去除掉原Stream中重复的元素，生成的新Stream中没有没有重复的元素。</li>
<li>filter方法对原Stream按照指定条件过滤，在新建的Stream中，只包含满足条件的元素，将不满足条件的元素过滤掉。</li>
<li>map方法将对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。为了提高处理效率，官方已封装好了，三种变形：mapToDouble，mapToInt，mapToLong。其实很好理解，如果想将原Stream中的数据类型，转换为double,int或者是long是可以调用相对应的方法。</li>
<li>flatMap方法与map方法类似，都是将原Stream中的每一个元素通过转换函数转换，不同的是，该换转函数的对象是一个Stream，也不会再创建一个新的Stream，而是将原Stream的元素取代为转换的Stream。如果转换函数生产的Stream为null，应由空Stream取代。flatMap有三个对于原始类型的变种方法，分别是：flatMapToInt，flatMapToLong和flatMapToDouble。</li>
<li>peek方法生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数，并且消费函数优先执行</li>
<li>skip方法将过滤掉原Stream中的前N个元素，返回剩下的元素所组成的新Stream。如果原Stream的元素个数大于N，将返回原Stream的后（原Stream长度-N）个元素所组成的新Stream；如果原Stream的元素个数小于或等于N，将返回一个空Stream。</li>
<li>sorted方法将对原Stream进行排序，返回一个有序列的新Stream。sorterd有两种变体sorted()，sorted(Comparator)，前者将默认使用Object.equals(Object)进行排序，而后者接受一个自定义排序规则函数(Comparator)，可按照意愿排序。</li>
</ul>
</blockquote>
<h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><ul>
<li>count方法将返回Stream中元素的个数。</li>
<li>forEach方法前面已经用了好多次，其用于遍历Stream中的所元素</li>
<li>forEachOrdered方法与forEach类似，都是遍历Stream中的所有元素，不同的是，如果该Stream预先设定了顺序，会按照预先设定的顺序执行（Stream是无序的），默认为元素插入的顺序。</li>
<li>max方法根据指定的Comparator，返回一个Optional，该Optional中的value值就是Stream中最大的元素</li>
<li>min方法根据指定的Comparator，返回一个Optional，该Optional中的value值就是Stream中最小的元素<h3 id="Short-circuiting"><a href="#Short-circuiting" class="headerlink" title="Short-circuiting"></a>Short-circuiting</h3></li>
<li><p>allMatch操作用于判断Stream中的元素是否全部满足指定条件。如果全部满足条件返回true，否则返回false。</p>
</li>
<li><p>anyMatch操作用于判断Stream中的是否有满足指定条件的元素。如果最少有一个满足条件返回true，否则返回false。</p>
</li>
<li><p>findAny操作用于获取含有Stream中的某个元素的Optional，如果Stream为空，则返回一个空的Optional。由于此操作的行动是不确定的，其会自由的选择Stream中的任何元素。在并行操作中，在同一个Stram中多次调用，可能会不同的结果。在串行调用时，Debug了几次，发现每次都是获取的第一个元素，个人感觉在串行调用时，应该默认的是获取第一个元素。</p>
</li>
<li><p>findFirst操作用于获取含有Stream中的第一个元素的Optional，如果Stream为空，则返回一个空的Optional。若Stream并未排序，可能返回含有Stream中任意元素的Optional。</p>
</li>
<li><p>limit方法将截取原Stream，截取后Stream的最大长度不能超过指定值N。如果原Stream的元素个数大于N，将截取原Stream的前N个元素；如果原Stream的元素个数小于或等于N，将截取原Stream中的所有元素。</p>
</li>
<li><p>noneMatch方法将判断Stream中的所有元素是否满足指定的条件，如果所有元素都不满足条件，返回true；否则，返回false.</p>
</li>
</ul>
<h2 id="Java信息安全"><a href="#Java信息安全" class="headerlink" title="Java信息安全"></a>Java信息安全</h2><h3 id="BASE64，MD5，SHA，HMAC，RIPEMD算法"><a href="#BASE64，MD5，SHA，HMAC，RIPEMD算法" class="headerlink" title="BASE64，MD5，SHA，HMAC，RIPEMD算法"></a>BASE64，MD5，SHA，HMAC，RIPEMD算法</h3><ul>
<li>Base64编码格式</li>
<li>base58编码(比特币使用)</li>
<li>Md5（摘要算法）</li>
<li>SHA (安全哈希算法，包含SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向散列算法。SHA-1，SHA-224和SHA-256适用于长度不超过2^64二进制位的消息。SHA-384和SHA-512适用于长度不超过2^128二进制位的消息。sha1已不推荐使用）</li>
</ul>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><ul>
<li>DES (Data Encryption Standard，数据加密标准)</li>
<li>3DES (Triple DES,三重数据加密算法（TDEA，Triple Data Encryption Algorithm）)</li>
<li>AES (Advanced Encryption Standard，高级加密标准)</li>
<li>RC4</li>
</ul>
<blockquote>
<p>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）,这种方法在密码学中叫做对称加密算法。</p>
</blockquote>
<h3 id="非对称加密算法RSA"><a href="#非对称加密算法RSA" class="headerlink" title="非对称加密算法RSA"></a>非对称加密算法RSA</h3><ul>
<li>RSA算法（Ron Rivest、Adi Shamir、Leonard Adleman，人名组合）</li>
</ul>
<blockquote>
<p>你只要想：既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</p>
</blockquote>
<blockquote>
<p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）</p>
</blockquote>
<h3 id="JAVA-证书制作"><a href="#JAVA-证书制作" class="headerlink" title="JAVA 证书制作"></a>JAVA 证书制作</h3><blockquote>
<p>使用java自带的工具keytool.exe生成</p>
</blockquote>
<h4 id="生成keyStore文件"><a href="#生成keyStore文件" class="headerlink" title="生成keyStore文件"></a>生成keyStore文件</h4><pre><code>    keytool -genkey -validity 36000 -alias www.felicity.org -keyalg RSA -keystore d:\felicity.keystore

*    -genkey表示生成密钥 
*    -validity指定证书有效期，这里是36000天 
*    -alias指定别名，这里是www.felicity.org
*    -keyalg指定算法，这里是RSA 
*    -keystore指定存储位置，这里是d:\felicity.keystore
</code></pre><blockquote>
<p>在这里我使用的密码为 123456</p>
</blockquote>
<h4 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h4><pre><code> keytool -export -keystore d:\felicity.keystore -alias  www.felicity.org -file d:\felicity.cer -rfc 
*    -export指定为导出操作 
*    -keystore指定keystore文件 
*    -alias指定导出keystore文件中的别名 
*    -file指向导出路径 
*    -rfc以文本格式输出，也就是以BASE64编码输出 
</code></pre><blockquote>
<p>这里的密码是 123456 </p>
</blockquote>
<blockquote>
<p>已经生成了.cer 的证书了</p>
</blockquote>
<h3 id="文件长度获取"><a href="#文件长度获取" class="headerlink" title="文件长度获取"></a>文件长度获取</h3><ul>
<li><p>① 如果要从网络中下载文件时，我们知道网络是不稳定的，也就是说网络下载时，read()方法是阻塞的，说明这时我们用inputStream.available()获取不到文件的总大小。<br>此时就需要通过来获取文件的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpURLConnection httpconn = (HttpURLConnection)url.openConnection();</span><br><span class="line">httpconn.getContentLength();//获取文件长度</span><br></pre></td></tr></table></figure>
</li>
<li><p>② 如果是本地文件的话，用此方法 inputStream.available() 就返回实际文件的大小。</p>
</li>
<li>③ 这个方法其实是通过文件描述符获取文件的总大小，而并不是事先将磁盘上的文件数据全部读入流中，再获取文件总大小</li>
</ul>
<h2 id="Java-Mail"><a href="#Java-Mail" class="headerlink" title="Java Mail"></a>Java Mail</h2><blockquote>
<p>邮件是在很多不同服务器之间进行数据传递，那么必然需要一个接收，发送传输规则</p>
</blockquote>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li>SMTP （simple mail transfer protocol） 即 简单邮件传输协议，属于TCP/IP协议族 用于发送邮件， 默认端口25</li>
<li>POP3 （post office protocol 3） 即邮局协议第3个版本, 用于接收邮件 默认端口 110 </li>
<li>IMAP （internet mail access protocol） 即 交互式邮件存取协议，类式POP3 ，不同点在于开启IMAP协议之后，在邮件客户端上的操作会反馈到邮件服务器上 默认端口143</li>
</ul>
<h3 id="发送邮件流程"><a href="#发送邮件流程" class="headerlink" title="发送邮件流程"></a>发送邮件流程</h3><ul>
<li>邮箱账户连接上邮件服务器，获取session</li>
<li>通过session，对外发送邮件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 地址</span><br><span class="line">Address sendFrom = new InternetAddress(fromUserName,pref,&quot;UTF-8&quot;);</span><br><span class="line">Address sendTo = new InternetAddress(to);</span><br><span class="line"></span><br><span class="line">// 连接mail</span><br><span class="line">Properties props = new Properties();</span><br><span class="line">props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);</span><br><span class="line">props.put(&quot;mail.smtp.host&quot;, &quot;smtp.163.com&quot;);</span><br><span class="line">Session session = Session.getInstance(props, new Authenticator() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	protected PasswordAuthentication getPasswordAuthentication() &#123;</span><br><span class="line">		return new PasswordAuthentication(fromUserName, fromUserPw);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">session.setDebug(true);</span><br><span class="line"></span><br><span class="line">// 创建邮件</span><br><span class="line">Message msg = new MimeMessage(session);</span><br><span class="line">msg.setSubject(pref + &quot; : &quot; + subject.getDes());</span><br><span class="line">msg.setContent(context, &quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">msg.setFrom(sendFrom);</span><br><span class="line">msg.addRecipient(Message.RecipientType.TO, sendTo);</span><br><span class="line"></span><br><span class="line">// 发送邮件</span><br><span class="line">Transport.send(msg);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h3><h3 id="接收邮件流程"><a href="#接收邮件流程" class="headerlink" title="接收邮件流程"></a>接收邮件流程</h3><h3 id="发送方的抽象"><a href="#发送方的抽象" class="headerlink" title="发送方的抽象"></a>发送方的抽象</h3><h2 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h2><blockquote>
<p>RMI 及网络间对象的传递与调用，需要对象的序列化，来进行传输与反序列</p>
</blockquote>
<blockquote>
<p>Java Bean 保存状态到本地</p>
</blockquote>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 操作</span><br><span class="line">String fileName = &quot;x.xx&quot;;</span><br><span class="line">// 写</span><br><span class="line">FileOutputStream fos = new FileOutputStream(fileName);</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(s);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">// 读</span><br><span class="line">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));</span><br><span class="line">Student rs = (Student) ois.readObject();</span><br><span class="line">Student rs2 = (Student) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>
<ul>
<li>serialVersionUID <blockquote>
<p>当需要序列化的类实现Serializable接口后，会自动或者让你生成一个serialVersionUID，目的: 如果一个对象在序列化存储到本地或内存中后，进行反序列时，如果serialVersionUID 不相等的，是不能反序列成功的。可用于CS中客户端的升级。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 2L;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类静态变量</p>
<blockquote>
<p>对象中，类静态变量是不会进行序列的。</p>
</blockquote>
</li>
<li><p>transient </p>
<blockquote>
<p>使用transient修饰的属性，也不参与序列</p>
</blockquote>
</li>
<li><p>反复序列</p>
<blockquote>
<p>一个对象 反复序列多次，序列数据只是按特定存储方式，存储了第一次序列的指针，所以容量增加不大。</p>
</blockquote>
</li>
<li><p>反复反序列</p>
<blockquote>
<p>反复反序列，因为存储的时候是做了第一次存储的指针处理的，所以读出来的东西是同一个</p>
</blockquote>
</li>
</ul>
<p><strong>关键点:在序列化的时候，如果这个对象以前序列化过，再次存储的时候，不关注这个对象现在属性是否已经变更，直接引用以前存储的对象指针进行序列存储；在反序列时，会根据存储顺序依次反序列</strong></p>
<ul>
<li>对敏感字段加密序列、反序列<blockquote>
<p>在调用 writeObject 时，会查看对象是否 拥有writeObject，如果有，代表自定义序列化逻辑，这里可对加密的属性进行自定义的扩展</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(ObjectOutputStream out) &#123;&#125;</span><br><span class="line">private void readObject(ObjectInputStream in) &#123;&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/线程/" rel="tag"># 线程</a>
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
            <a href="/tags/加密算法/" rel="tag"># 加密算法</a>
          
            <a href="/tags/Stream/" rel="tag"># Stream</a>
          
            <a href="/tags/lambda/" rel="tag"># lambda</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/21/Nginx笔记/" rel="prev" title="Nginx 笔记">
                Nginx 笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="Felicity.R.try" />
          <p class="site-author-name" itemprop="name">Felicity.R.try</p>
           
              <p class="site-description motion-element" itemprop="description">Java开发工程师</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/rtry" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:532454550@qq.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuffer-and-StringBuilder"><span class="nav-number">1.</span> <span class="nav-text">StringBuffer and StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">2.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两个特性"><span class="nav-number">2.1.</span> <span class="nav-text">两个特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-1-5之前对线程同步的方式"><span class="nav-number">3.</span> <span class="nav-text">Java 1.5之前对线程同步的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">3.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">3.2.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用场景"><span class="nav-number">3.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">4.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的数据结构"><span class="nav-number">4.1.</span> <span class="nav-text">常见的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">4.2.</span> <span class="nav-text">二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展（对数-）"><span class="nav-number">4.3.</span> <span class="nav-text">扩展（对数 ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-实现"><span class="nav-number">4.4.</span> <span class="nav-text">Java 实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">5.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决目的"><span class="nav-number">5.1.</span> <span class="nav-text">解决目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">5.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-工具类"><span class="nav-number">5.3.</span> <span class="nav-text">Executors 工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插件"><span class="nav-number">6.</span> <span class="nav-text">插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Eclipse-Scala-插件"><span class="nav-number">6.1.</span> <span class="nav-text">Eclipse  Scala 插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maven-maven-assembly-plugin-插件"><span class="nav-number">6.2.</span> <span class="nav-text">Maven maven-assembly-plugin 插件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Puzzlers"><span class="nav-number">7.</span> <span class="nav-text">Java Puzzlers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Generics-泛型"><span class="nav-number">8.</span> <span class="nav-text">Java Generics 泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Lambda-表达式"><span class="nav-number">9.</span> <span class="nav-text">Java Lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式"><span class="nav-number">9.1.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回"><span class="nav-number">9.2.</span> <span class="nav-text">返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部接口单一方法替代"><span class="nav-number">9.3.</span> <span class="nav-text">内部接口单一方法替代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数体引用值"><span class="nav-number">9.4.</span> <span class="nav-text">函数体引用值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合迭代"><span class="nav-number">9.5.</span> <span class="nav-text">集合迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数接口"><span class="nav-number">9.6.</span> <span class="nav-text">函数接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Stream-语法"><span class="nav-number">10.</span> <span class="nav-text">Java Stream 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用流程"><span class="nav-number">10.1.</span> <span class="nav-text">使用流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建方法"><span class="nav-number">10.2.</span> <span class="nav-text">创建方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Intermediate"><span class="nav-number">10.3.</span> <span class="nav-text">Intermediate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Terminal"><span class="nav-number">10.4.</span> <span class="nav-text">Terminal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Short-circuiting"><span class="nav-number">10.5.</span> <span class="nav-text">Short-circuiting</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java信息安全"><span class="nav-number">11.</span> <span class="nav-text">Java信息安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BASE64，MD5，SHA，HMAC，RIPEMD算法"><span class="nav-number">11.1.</span> <span class="nav-text">BASE64，MD5，SHA，HMAC，RIPEMD算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对称加密算法"><span class="nav-number">11.2.</span> <span class="nav-text">对称加密算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非对称加密算法RSA"><span class="nav-number">11.3.</span> <span class="nav-text">非对称加密算法RSA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA-证书制作"><span class="nav-number">11.4.</span> <span class="nav-text">JAVA 证书制作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成keyStore文件"><span class="nav-number">11.4.1.</span> <span class="nav-text">生成keyStore文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成自签名证书"><span class="nav-number">11.4.2.</span> <span class="nav-text">生成自签名证书</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件长度获取"><span class="nav-number">11.5.</span> <span class="nav-text">文件长度获取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Mail"><span class="nav-number">12.</span> <span class="nav-text">Java Mail</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#协议"><span class="nav-number">12.1.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送邮件流程"><span class="nav-number">12.2.</span> <span class="nav-text">发送邮件流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送带附件的邮件"><span class="nav-number">12.3.</span> <span class="nav-text">发送带附件的邮件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收邮件流程"><span class="nav-number">12.4.</span> <span class="nav-text">接收邮件流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送方的抽象"><span class="nav-number">12.5.</span> <span class="nav-text">发送方的抽象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Serializable-接口"><span class="nav-number">13.</span> <span class="nav-text">Serializable 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本操作"><span class="nav-number">13.1.</span> <span class="nav-text">基本操作</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Felicity.R.try</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
