---
title: 部分源码笔记
date: 2016-03-06
categories: 工作与学习
tags: [java,线程,数据结构,加密算法]
---
## 一 ：StringBuffer and StringBuilder
1. 两者兼容API
2. StringBuffer 线程安全
3. StringBuilder 多线程不安全，但是更快

> Spring 在同一事务中，查询两次，会返回上一次查询后变更后的值，及这个值为持久化状态的 

> Main 方法执行中，如果另起线程中，线程挂起，主线程是不会关闭的
> 
> JUnit 执行测试时，如果另起线程中，线程挂起，主线程任然会关闭



## 二 ：线程
### 两个特性
在多个线程共享某个对象 *X* 时，X首先存在于主线程的堆内存中，不同的线程对X的操作实际上是，分3步完成，首先拷贝副本到线程栈中，然后执行某些操作，最后将X回刷回主线程的堆内存。

1. 可见性 ：
多线程中，某些线程对X进行修改，其他线程也能看到被修改的X 此为可见性

2. 有序性 ：
对X的操作，如果要求必须等到前一个线程完整之后，后一次线程才操作 此为有序性

## 三 ：1.5之前对线程同步的方式
### synchronized 

* 修饰一个代码块，其同步的作用域是{}之间的代码，锁是（）里面的东西，作用的对象是调用该代码块的类（及一个时间只有一个对象可以调用这个代码块）
* 修饰一个方法，其同步的是作用域是整个方法里面的代码，锁 是当前方法所属的对象，作用的对象是调用当前方法的对象（及一个时间只有一个对象可以调用该方法）
* 修饰一个静态方法，其同步的作用域是整个方法里面的代码，锁是当前方法所属类A，而类所有的实例都是共用一个类的，故对所有实例都有效（及一个时间只有一个对象可以调用该方法，更加严格的，两个类A的实例给其他对象加锁用，但这两个类A都是用的同一把锁）
* 修改一个类，其所有方法同步，锁是当前类A，同第3点

### volatile
volatile 具有synchronized的可见性，不具有synchronized的有序性(原子性)，

* 其性能优于synchronized
* 严格遵循 volatile 的使用条件 —— **即变量真正独立于其他变量和自己以前的值** 
* volatile只能保证对单次读/写的原子性

对volatile 修饰的变量的与普通的变量修改的区别有两点

* 修改volatile变量的会强制将修改后的值刷新到主内存中
* 修改volatile变量的会造成其他线程对该变量应用的失效

volatile关键字只能保证get操作是读取的是最新的值，而set操作会写到内存中，会强制重新从系统内存里把数据读到处理器缓存里，并不具有原子性

####### 适用场景

* 一个地方写，很多地方读取，这个时候使用volatile会让每个地方获取的值都是最新的
* volatile 和 synchronized 实现 “开销较低的读－写锁”

		public class CheesyCounter {
    
		    private volatile int value;
		
		    public int getValue() { 
				return value;
		 	}
		    public synchronized int increment() {
		        return value++;
		    }
		}



## 四 ：数据结构
* 从逻辑上说：集合，线形，树形，图形
* 从物理上说：顺序，链式，索引，散列

### 常见的数据结构
1.	线性表（链表）
2.	队列 （先进先出）
3.	栈（后进先出）
4.	树 
5.	图 


## 五：ThreadPoolExecutor 线程池 （从1.5版本开始）
### 解决目的 
线程的创建，消费，对内存的开销很大，创建线程也会带来额外的性能支出（如创建时间）

### 构造方法（4个 但都是由下面这个变种）

	  	public ThreadPoolExecutor(int corePoolSize,
	                              int maximumPoolSize,
	                              long keepAliveTime,
	                              TimeUnit unit,
	                              BlockingQueue<Runnable> workQueue,
	                              ThreadFactory threadFactory,
	                              RejectedExecutionHandler handler) {
	        if (corePoolSize < 0 ||
	            maximumPoolSize <= 0 ||
	            maximumPoolSize < corePoolSize ||
	            keepAliveTime < 0)
	            throw new IllegalArgumentException();
	        if (workQueue == null || threadFactory == null || handler == null)
	            throw new NullPointerException();
	        this.corePoolSize = corePoolSize;
	        this.maximumPoolSize = maximumPoolSize;
	        this.workQueue = workQueue;
	        this.keepAliveTime = unit.toNanos(keepAliveTime);
	        this.threadFactory = threadFactory;
	        this.handler = handler;
	    }

#### 说明：
* corePoolSize :核心池大小数，在创建线程池对象的时候，核心池的大小其实是0的，然后在往线程池里面添加任务的时候，初始化一个线程
* maximumPoolSize:池最大数，表示当前当前线程池允许的最大线程数
* keepAliveTime：空闲线程允许存活时间，当线程空闲时，这个线程等待多长时间进行释放回收，
* TimeUnit: 时间类型，keepAliveTime的时间类型参数（7种）
* workQueue：阻塞队列，用来存储等待执行的任务，有多种如 `ArrayBlockingQueue` `LinkedBlockingQueue`  `SynchronousQueue`

		ArrayBlockingQueue：基于数组实现，初始时，需要指定大小，先进先出
		LinkedBlockingQueue：基于链表的实现，初始时，可不指定大小，默认为Int的max，先进先出
		SynchronousQueue：该队列不会保存任务，直接提交执行

* threadFactory ：线程工厂
* handler：表示拒绝服务的策略(有4种)

		ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
		ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
		ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
		ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 


### Executors 处理线程池的工具类
* ExecutorService service = Executors.newFixedThreadPool(4);
	
	创建一个固定大小的线程池，加入一个任务，就创建一个线程池，直到满了线程池的核心池大小，然后再加入的时候，会等空闲的线程池

* ExecutorService service = Executors.newCachedThreadPool();

	创建一个可变的线程池，加入一个任务，先看有没有空闲线程，有的话直接取来，没有的话，创建一个新的


* ScheduledExecutorService  service = Executors.newScheduledThreadPool(3);

	创建一个固定大小的线程池，用于处理定时及周期性任务注意其返回ScheduledExecutorService  

* ExecutorService service = Executors.newSingleThreadExecutor();
	
	创建一个独立的线程池，只有一个线程来执行，保证队列里面的**时序**






## 六：eclipse 插件
 
### Scala eclipse 插件
安装文档及说明地址： http://scala-ide.org/download/current.html

### Maven maven-assembly-plugin 插件
* 在 pom.xml < build> 里面 添加插件

			<plugin>
					<!-- url -->
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-assembly-plugin</artifactId>
					<version>3.0.0</version>

					<!-- 配置--> 
					<configuration>
						<appendAssemblyId>false</appendAssemblyId>
						<!-- 依赖配置文件 -->
						<descriptors>
							<descriptor>src/main/resources/assembly.xml</descriptor>
						</descriptors>
						<!-- 主函数入口 -->
						<archive>
							<manifest>
								<mainClass>pt.sicau.edu.cn.spark.test.StreamPublicSecond</mainClass>
							</manifest>
						</archive>
					</configuration>
					<!-- 执行 -->
					<executions>
						<execution>
							<id>make-assembly</id>
							<phase>package</phase>
							<!-- 单例 -->
							<goals>
								<goal>single</goal>
							</goals>
						</execution>
					</executions>
				</plugin>
			</plugins>


* assembly.xml

		<assembly xmlns="http://maven.apache.org/ASSEMBLY/2.0.0"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd">
		<id>test</id>
		<includeBaseDirectory>false</includeBaseDirectory>
		<formats>
			<format>jar</format>
		</formats>
	
		<fileSets>
			<!-- resources -->
			<fileSet>
				<directory>${project.basedir}\src\main\resources</directory>
				<outputDirectory>\</outputDirectory>
			</fileSet>
	
			<!-- my app class -->
			<fileSet>
				<directory>${project.basedir}\target\classes</directory>
				<outputDirectory>\</outputDirectory>
			</fileSet>
		</fileSets>
	
		<dependencySets>
			<!-- denpendency jars -->
			<dependencySet>
				<!--将依赖解压-->
				<unpack>true</unpack>
				<useProjectArtifact>true</useProjectArtifact>
				<outputDirectory>\</outputDirectory>
				<scope>runtime</scope>
			</dependencySet>
		</dependencySets>
	
	</assembly>


## 七： Java Puzzlers
* URL的equals比对方式,在有网时，会根据解析地址来判断，地址相同则相同，在没网时，会根据字符串来判断，但是域名不区分大小写
* j++ 与 ++j 这种运算存在一个临时中间变量
* static 方法是类的，不会被继承
* for 循环只有一行时，可以省下{} ，但是不能是赋值语句
* Integer 与int相比，值等就等，Integer对象之间比较，在byte范围内，必然相等
* BigInteger.add()方法，返回的是加的结果，原值是不会改变的
* Integer 静态方法，可以方便的转换2/8/16进制
* 基本上所有容器类的构造方法都有参数为容器的
* << 与 >> 为位运算，表示将二进制左右移动，很方便的实现开方
* String.format() 工具类，可快速格式化
* Char 在英文编码范围是有缓存的，故包装类之间比较这个范围，是相等的
* Math.abs() Integer.min() 的时候，自身相等
* java的重载方法，在调用的时候，会选取最适中的
* Number是所有数字类的父类 
* Class.forName() 将类加入编译环境 ，c.newInstance() 会调用无参构造方法
* Timer 与TimerTask 两个是java处理定时器相关的两个类




## 八： java generics 泛型
* 必须先声明 <T>  可在类上 或者方法上声明 
* 是否拥有泛型方法 跟是否是泛型类 无关
* 泛型在编译阶段中，会将泛型进行擦除，也就是说成功编译后的泛型，是不包含任何泛型信息的
* 多重泛型 类放第一位，接口从第二位开始，用& 连接


## 九： java lambda










##一零： java信息安全
### BASE64，MD5，SHA，HMAC，RIPEMD算法
* Base64编码格式
* base58编码(比特币使用)
* Md5（摘要算法）
* SHA (安全哈希算法，包含SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向散列算法。SHA-1，SHA-224和SHA-256适用于长度不超过2^64二进制位的消息。SHA-384和SHA-512适用于长度不超过2^128二进制位的消息。sha1已不推荐使用）

### 对称加密算法
* DES (Data Encryption Standard，数据加密标准)
* 3DES (Triple DES,三重数据加密算法（TDEA，Triple Data Encryption Algorithm）)
* AES (Advanced Encryption Standard，高级加密标准)
* RC4

> 对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）,这种方法在密码学中叫做对称加密算法。

### 非对称加密算法RSA
* RSA算法（Ron Rivest、Adi Shamir、Leonard Adleman，人名组合）

> 你只要想：既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。

> 非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）


### JAVA 证书制作
> 使用java自带的工具keytool.exe生成

####1. 生成keyStore文件

		keytool -genkey -validity 36000 -alias www.felicity.org -keyalg RSA -keystore d:\felicity.keystore
	
	*	-genkey表示生成密钥 
	*	-validity指定证书有效期，这里是36000天 
	*	-alias指定别名，这里是www.felicity.org
	*	-keyalg指定算法，这里是RSA 
	*	-keystore指定存储位置，这里是d:\felicity.keystore
	
> 在这里我使用的密码为 123456



####2.生成自签名证书

 	keytool -export -keystore d:\felicity.keystore -alias  www.felicity.org -file d:\felicity.cer -rfc 
	*	-export指定为导出操作 
	*	-keystore指定keystore文件 
	*	-alias指定导出keystore文件中的别名 
	*	-file指向导出路径 
	*	-rfc以文本格式输出，也就是以BASE64编码输出 

> 这里的密码是 123456 

> 已经生成了.cer 的证书了


| Item      |    Value | Qty  |
| :-------- | --------:| :--: |
| Computer  | 1600 USD |  5   |
| Phone     |   12 USD |  12  |
| Pipe      |    1 USD | 234  |


### 文件长度获取

* ① 如果要从网络中下载文件时，我们知道网络是不稳定的，也就是说网络下载时，read()方法是阻塞的，说明这时我们用inputStream.available()获取不到文件的总大小。
此时就需要通过来获取文件的大小。
```
HttpURLConnection httpconn = (HttpURLConnection)url.openConnection();
httpconn.getContentLength();//获取文件长度
```

* ② 如果是本地文件的话，用此方法 inputStream.available() 就返回实际文件的大小。
* ③ 这个方法其实是通过文件描述符获取文件的总大小，而并不是事先将磁盘上的文件数据全部读入流中，再获取文件总大小
